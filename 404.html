<!DOCTYPE html>
<html lang="zh-Hans-CN">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, height=device-height">
	<style>
		body{
			display: none;
		}
	</style>
</head>

<body>
	<table><tr><td>
		<div id="not-supported">
			请用<a href="https://www.google.cn/intl/zh-CN/chrome/browser/index.html">Chrome</a>（安装和更新需翻<!---->墙）浏览本站。<br>
			<br>
			Windows XP用户可以尝试使用Firefox 52：<br>
			- <a href="https://download-installer.cdn.mozilla.net/pub/firefox/releases/52.1.0esr/win32/zh-CN/Firefox%20Setup%2052.1.0esr.exe">Firefox 52.1.0esr win32</a><br>
			- <a href="https://download-installer.cdn.mozilla.net/pub/firefox/releases/52.1.0esr/win64/zh-CN/Firefox%20Setup%2052.1.0esr.exe">Firefox 52.1.0esr win64</a><br>
			<br>
			（2017/06/05）</div>
		<div id="not-found" style="display: none">
		   	404 Not Found</div>
	</td></tr></table>
	<script>"use strict";
		this.onerror = function(){
			document.title = "不支持";
			var hash = document.location.hash.slice(1);
			var url0 = document.location.href;
			var reg = /^[^:]+:\/+[^/]+\//;
			if((url0.match(reg) || [0])[0] !== (hash.match(reg) || [1])[0]) return;
			history.replaceState(null, null, hash);
			if(document.location.href !== hash) history.replaceState(null, null, url0);
		};
	</script>
	<script>"use strict";
		a => function*(...[{a}]){``};
		Promise.resolve(document.append(), );
		Reflect;

		onerror = null;
		if(top === self){
			try{
				document.title = "Loading";
				const hash = document.location.hash.slice(1);
				if(!hash.startsWith(document.location.origin)) throw null;
				const url0 = document.location.href;
				history.replaceState(null, null, hash);
				if(document.location.href !== hash) throw history.replaceState(null, null, url0);
				if(!localStorage.length) localStorage.setItem(`"use strict";
					if(top !== self) throw null;
					Reflect;
					onload = null;
					[...document.childNodes].forEach(node => node instanceof DocumentType || node.remove());
					const meta = document.createElement("meta");
					meta.setAttribute("charset", "utf-8");
					const head = document.createElement("head");
					head.append(meta);
					const html = document.createElement("html");
					html.append(head, document.createElement("body"));
					document.append(html);
					Promise.resolve().then(() => {
						history.replaceState(null, null, url0);
						try{
							Reflect.deleteProperty(self, "a");
						}catch(error){}

						const setup = localStorage.key(0);
						const library_source = \`
							const run = thunk => {
								const run = thunk => {
									try{
										thunk();
									}catch(error){
										setTimeout(() => {
											throw error;
										});
									}
								};
								try{
									return run(thunk());
								}catch(error){}
								Promise.resolve().then(() => run(() => thunk()()));
							};
							const hell = () => {
								const hell = callback => {
									if(!callbacks) return run(() => () => callback(result));
									callbacks.push(callback);
								};
								let result;
								let callbacks = [];
								hells.add(hell);
								return [hell, result1 => {
									if(!callbacks) return;
									result = result1;
									const callbacks1 = callbacks;
									callbacks = null;
									callbacks1.forEach(hell);
								}];
							};
							const is_hell = target => hells.has(target);
							const tickline = (...ticks) => {
								switch(ticks.length){
								case 0:
									return target => {
										if(!is_hell(target)) return target;
										let target1;
										target(target => target1 = [tickline()(target)]);
										if(target1) return target1[0];
										const [, resolve] = [target1] = hell();
										target(target => {
											target = tickline()(target);
											if(is_hell(target)) return target(resolve);
											resolve(target);
										});
										return target1;
									};
								case 1:
									return target => {
										target = tickline()(target);
										if(is_hell(target)){
											const [hell0, resolve] = hell();
											target(target => resolve(tickline()((0, ticks[0])(target))));
											return tickline()(hell0);
										}
										try{
											return tickline()((0, ticks[0])(target));
										}catch(error){
											setTimeout(() => {
												throw error;
											});
										}
										return hell()[0];
									};
								case 2: 
									return target => tickline(ticks[1])(tickline(ticks[0])(target));
								}
								return tickline(ticks.shift(), tickline(...ticks));
							};
							const gen2tick = gen => tickline(target => {
								target = gen.next(target);
								return target.done ? target.value : gen2tick(gen)(target.value);
							});
							const genfn2tick = genfn => function(){
								return gen2tick(genfn.apply(this, arguments))();
							};
							const prom2hell = promise => dp.get(promise) || (() => {
								const [hell0, resolve] = hell();
								Promise.resolve(promise).then(
									result => resolve([null, result]),
									error => resolve([error]),
								);
								dp.set(promise, hell0);
								return hell0;
							})();
							const hells = new WeakSet;
							const dp = new WeakMap;

							({run, hell, is_hell, tickline, gen2tick, genfn2tick, prom2hell});
						\`;
						const library = self.eval('"use strict";' + library_source);
						const {run, hell, is_hell, tickline, gen2tick, genfn2tick, prom2hell} = library;

						const blocker = event => crash && event.stopImmediatePropagation();
						let crash = false;
						addEventListener("unload", blocker);
						addEventListener("beforeunload", blocker);
						addEventListener("error", event => {
							const timer = setTimeout(() => {
								if(crash) return;
								crash = true;
								if((localStorage || {}).setItem) localStorage.setItem(setup, JSON.stringify({source: \`
									const {hell, tickline} = library;

									const pre = document.createElement("pre");
									const button = document.createElement("button");
									document.title = "Crash";
									const code = document.createElement("code");
									code.textContent = unescape("\${escape(event.message + "\\n@" + event.filename + ":" + event.lineno + ":" + event.colno)}");
									button.textContent = "Reload";
									const [hell0, resolve] = hell();
									button.addEventListener("click", () => {
										button.disabled = true;
										button.textContent = "Reloading";
										resolve();
									});
									pre.append(code);
									document.body.append(pre, button);
									button.focus();
									return () => tickline(() => {
										pre.remove();
										button.remove();
									})(hell0);
								\`}));
								history.go(0);
							});
							event.prevent_reload = () => clearTimeout(timer);
						});

						const update = genfn2tick(function*(){
							if(source === ({source} = boot) || lock) return;
							lock = true;
							yield (cancel || (() => {}))();
							Function('"use strict";' + source);
							document.title = "Loading";
							cancel = self.eval('"use strict"; (library, library_source) => {' + source + "}")(library, library_source);
							lock = false;
						});
						let source;
						let cancel;
						let lock = false;
						let boot = localStorage.getItem(setup);
						addEventListener("storage", () => {
							boot = JSON.parse(localStorage.getItem(setup));
							update();
						});
						if(boot){
							boot = JSON.parse(boot);
							update();
						}else{
							boot = {};
						}

						const check = () => {
							xhr.open("GET", "/boot.js");
							xhr.setRequestHeader("Cache-Control", "max-age=0");
							if(boot.tag){
								const [, value] = [t] = boot.tag;
								t = new Map([
									["ETag", "If-None-Match"],
									["Last-Modified", "If-Modified-Since"],
								]).get(t);
								if(t !== undefined){
									xhr.setRequestHeader(t, value);
									t = boot;
								}
							}
							xhr.send();
							setTimeout(([hell0] = hell())[1], 15e3);
						};
						let t;
						let hell0;
						const xhr = new XMLHttpRequest;
						xhr.addEventListener("loadend", ({target: {status}}) => {
							if(status >= 200 && status < 300){
								t = {source: xhr.responseText};
								for(let key of ["ETag", "Last-Modified"]){
									const value = xhr.getResponseHeader(key);
									if(value === null) continue;
									t.tag = [key, value];
									break;
								}
							}else if(status === 404){
								t = {source: 'document.title = ""'};
							}else if(status !== 304){
								return requestAnimationFrame(check);
							}
							t.date = xhr.getResponseHeader("Date") || NaN;
							if(!(new Date(t.date) <= new Date(boot.date))){
								localStorage.setItem(setup, JSON.stringify(t));
								boot = t;
								update();
							}
							t = null;
							hell0(() => requestAnimationFrame(check));
						});
						xhr.addEventListener("progress", () => new Date(xhr.getResponseHeader("Date") || NaN) <= new Date(boot.date) && check());
						check();
					}).catch(error => setTimeout(() => {
						throw error;
					}));
					const url0 = document.location.href.slice(document.location.origin.length);
					history.replaceState(null, null, "a");
				`, "");
				history.go(0);
			}catch(error){
				const check = () => requestAnimationFrame(() => {
					xhr.open("GET", document.location);
					xhr.setRequestHeader("Range", "bytes=0-0");
					xhr.send();
				});
				document.title = "";
				document.querySelector("#not-supported").style.display = "none";
				document.querySelector("#not-found").style.display = "";
				const xhr = new XMLHttpRequest;
				xhr.addEventListener("readystatechange", () => {
					if(!xhr.status) return;
					if(xhr.status === 404) return check();
					document.location.reload();
					xhr.abort();
				});
				check();
			}
		}else{
			document.querySelector("#not-supported").style.display = "none";
		}
	</script>
	<style>
		table{
			display: inline;
			border-collapse: collapse;
		}

		td{
			padding: 0;
		}

		div{
			font-size: 1.1em;
			font-family: consolas, menlo, 黑体, monospace;
			line-height: 1.8em;
			text-align: left;
			background-color: white;
		}

		div a:not([hidden]){
			text-decoration: none;
			display: inline-block;
			position: relative;
		}

		div a:link,
		div a:active{
			color: black;
		}

		div a:visited:not([hidden]){
			color: black;
		}

		div a:focus{
			outline: none;
		}

		div a::before,
		div a::after{
			display: block;
			position: absolute;
			width: 100%;
			height: 0;
			bottom: 0;
			border-bottom-width: 1px;
			border-bottom-color: black;
			content: "";
		}

		div a::before{
			border-bottom-style: solid;
		}

		div a:visited::before{
			border-bottom-color: white;
		}

		div a::after{
			border-bottom-style: dashed;
		}

		div a:focus,
		div a:hover{
			background-color: rgba(0, 0, 0, .17);
		}

		body{
			display: block;
			text-align: center;
			overflow: auto;
			border: none;
			margin: 8px;
		}
	</style>
</body>

</html>
